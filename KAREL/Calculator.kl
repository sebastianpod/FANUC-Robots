PROGRAM Calculator

%COMMENT = 'simple caluclator'	--directive: set program comment visible in the select menu
%NOLOCKGROUP					--directive: no motion group will be lock during program execution
%NOPAUSESHFT					--directive: program execution will not be aborted when shift button realese

VAR
num1:REAL
num2:REAL
exponent:INTEGER
result:REAL
operation:STRING[3]
operation_num:INTEGER
i:INTEGER
j:INTEGER
ans:STRING[1]
ans2:STRING[1] 
decimal_str:STRING[2]
decimal_int:INTEGER
num1_inverse:REAL
sts:STRING[1] 
second:INTEGER
minute:INTEGER
hour:INTEGER
day:INTEGER
month:INTEGER
year:INTEGER
whole:INTEGER
second_str:STRING[3]
minute_str:STRING[3]
hour_str:STRING[3]
day_str:STRING[3]
month_str:STRING[3]
year_str:STRING[5]
file_save: FILE
time_struct:INTEGER
file_path:STRING[30]
result_log:STRING[30]
num1_str:STRING[10]
num2_str:STRING[10]
result_str:STRING[10]
exponent_str:STRING[10]
name:STRING[40]
password:STRING[40]
pass_temp:STRING[40]
register_no:INTEGER
real_flag:BOOLEAN
r_val: REAL
status:INTEGER
user_name:STRING[40]
user_num:INTEGER
user_num_temp:INTEGER

BEGIN
	
	FORCE_SPMENU(TP_PANEL , SPI_TPUSER,1)	--display USER screen
	WRITE(CHR(128), CHR (137))						--clear USER screen
	WRITE TPERROR (CHR (128), CHR (137))			--clear ERROR screen

	login_screen::
	WRITE('Create new account or sign in ',CR,
	CR,'Press 1 to create an account',CR,
	CR,'Press 2 to sign in ',CR)							--display user's tips
	READ(sts)											--login options choose
	WRITE(CHR(128), CHR (137))						--clear USER screen
	IF sts<>'1' THEN									--chocie correctness check	
		IF sts<>'2' THEN								--choice correcntess check
			GOTO login_screen							--on error jump to login screen
		ELSE
			login::												--login label
			GET_REG(1,real_flag,register_no,r_val,status)		--get number of defined users
			IF register_no=1 THEN								--check if any account exist
				WRITE('No account was created',CR,			
				'Please create an account',CR,
				'Press any key to proceed ')						--message
				READ(sts)										--register any key press						
				WRITE(CHR(128),CHR(137))					--clear USER screen
				GOTO acc_screen								--if true jump to account creation screen
			ENDIF
			register_no=register_no-1							--preapration for FOR loop					
			j=0													--zero oridinal number variable
			FOR i=1 TO register_no DO						--FOR loop searching user names in string registers list
				IF i MOD 2 = 1 THEN							--only odd string registers are valid
					j=j+1										--set oridinal number
					GET_STR_REG(i,user_name,status)		--get user name and save it into user_name variable
					WRITE(CR,j,'. ',user_name)					--display oridinal number and user name
				ENDIF
			ENDFOR
			user_select::										--user select label
			WRITE(CR,CR,'Select your account number ')		--user name choice request
			READ(user_num)									--read user name
			IF user_num>j THEN								--user name correctness check
				GOTO user_select								--on error go to label
			ENDIF
			pass_screen::										--pass screen label
			user_num_temp=user_num							--copy original user number value to the temporary variable
			user_num=user_num+(user_num-1)					--only even string registers are valid		
			GET_STR_REG(user_num,user_name,status)		--copy user name from string variable to user_name variable
			WRITE(CHR(128), CHR (137))						--clear USER screen
			WRITE('Login: ',user_name,CR,'Password: ')		--password enter request
			READ(password)									--read password
			user_num_temp=user_num_temp*2					--preparation for FOR loop
			GET_STR_REG(user_num_temp,pass_temp,status)--get specific user's password
			IF pass_temp<>password THEN					--password correctness check
				WRITE(CHR(128), CHR (137))					--clear USER screen
				WRITE('Incorrect password!')					--message
				GOTO pass_screen							--on error go to label
			ENDIF
			
		ENDIF
	ELSE														--alternative: create new user
		acc_screen::											--account creation label
		real_flag=OFF											--set boolean variable for get_reg instruction
		GET_REG(1,real_flag,register_no,r_val,status)			--get number of existing users
		WRITE('Enter your name: ',CR)							--new user name input request
		READ(name)											--read name
		SET_STR_REG(register_no,name,status)				--set new string register with new user's name				
		register_no=register_no+1								--increment users number register 
		WRITE(CR,'Set password: ',CR)						--new user password request
		READ(password)										--read password
		SET_STR_REG(register_no,password,status)			--set next string register with new user's password
		register_no=register_no+1								--increment users number register
		SET_INT_REG(1,register_no,status)					--user numbers register update
		WRITE(CHR(128), CHR (137))							--clear USER screen
		GOTO login												--go to login label	
	ENDIF

	WRITE(CHR(128), CHR (137))
	WRITE('CALCULATOR'::25::1,CR,CR,'Press ENTER to start ')	--show heading
	READ(sts)														--register Enter button press
	WRITE(CHR(128),CHR(137))									--clear USER screen

	WRITE('Index:',CR,'+','sum'::7::1,CR,'-','difference'::14::1,
			CR,	'x','product'::11::1,CR,'/','fraction'::12::1,CR,
			'^','power'::9::1,CR,'Include trigonometric functions:',
			CR,'sin, cos, tg, ctg',CR)								-- show available operations (with text formating)

	start::									--start label	
	WRITE(CR,'Enter first number: ')		--input data request
	READ(num1)							--read first number

	symbol_input::							--symbol input label
	WRITE(CR,'Enter operation symbol: ')	--input math symbol request
	READ(operation)						--read math symbol

	IF operation<>'+' THEN																		--math symbols correctness check												
		IF operation<>'-' THEN																	--math symbols correctness check
			IF operation<>'x' THEN																--math symbols correctness check
				IF operation<>'X' THEN															--math symbols correctness check (both miniscule and capital 'X' are permitted)
					IF operation<>'/' THEN														--math symbols correctness check (both miniscule and capital 'X' are permitted)
						IF operation<>'sin' THEN												--math symbols correctness check (both miniscule and capital 'sin' are permitted)
							IF operation<>'SIN' THEN											--math symbols correctness check (both miniscule and capital 'sin' are permitted)
								IF operation<>'cos' THEN										--math symbols correctness check (both miniscule and capital 'cos' are permitted)
									IF operation<>'COS' THEN									--math symbols correctness check (both miniscule and capital 'cos' are permitted)
										IF operation<>'tg' THEN								--math symbols correctness check (both miniscule and capital 'tg' are permitted)
											IF operation<>'TG' THEN							--math symbols correctness check (both miniscule AND capital 'tg' are permitted)
												IF operation<>'ctg' THEN						--math symbols correctness check (both miniscule and capital 'ctg' are permitted)
													IF operation<>'CTG' THEN					--math symbols correctness check (both miniscule and capital 'ctg' are permitted)								
														IF operation<>'^' THEN					--math symbols correctness check
															WRITE(CR,'Incorrect symbol!',CR)	--error handling message	
															GOTO symbol_input				--on error jump to label
														ELSE
															WRITE(CR,'Enter exponent: ')		--exponent input request if power operation was selected
															READ(exponent)					--read exponent
														ENDIF
													ELSE 
														GOTO decimal_input					--jump to decimal input label if CTG function was selected
													ENDIF
												ELSE
													GOTO decimal_input						--jump to decimal input label if ctg function was selected
												ENDIF
											ELSE
												GOTO decimal_input							--jump to decimal input label if TG function was selected
											ENDIF
										ELSE
											GOTO decimal_input								--jump to decimal input label if tg function was selected
										ENDIF
									ELSE
										GOTO decimal_input									--jump to decimal input label if COS function was selected
									ENDIF										
								ELSE
									GOTO decimal_input										--jump to decimal input label if cos function was selected
								ENDIF
							ELSE
								GOTO decimal_input											--jump to decimal input label SIN function was selected
							ENDIF
						ELSE
							GOTO decimal_input												--jump to decimal input label sin function was selected
						ENDIF
					ELSE
						WRITE(CR,'Enter second number: ')									--input data request if divide operation was selected
						READ(num2)															--read divisor
					ENDIF
				ELSE
					WRITE(CR,'Enter second number: ')						--input data request if multiplication (capital) operation was selected
					READ(num2)												--read factor
				ENDIF
			ELSE
				WRITE(CR,'Enter second number: ')							--input data request if multiplication (miniscula) operation was selected
				READ(num2)													--read factor
			ENDIF															
		ELSE
			WRITE(CR,'Enter second number: ')								--input data request if difference operation was selected
			READ(num2)														--read term
		ENDIF
	ELSE
		WRITE(CR,'Enter second number: ')									--input data request if sum operation was selected
		READ(num2)															--read addend
	ENDIF

	decimal_input::																		--decimal input label
	WRITE(CR,'Set decimal places number (max=9): ')									--input data request
	READ(decimal_str)																	--read decimal number as a string
	IF decimal_str<>'0' THEN															--decimal number correctness check
		IF decimal_str<>'1' THEN														--decimal number correctness check
			IF decimal_str<>'2' THEN													--decimal number correctness check
				IF decimal_str<>'3' THEN												--decimal number correctness check
					IF decimal_str<>'4' THEN											--decimal number correctness check
						IF decimal_str<>'5' THEN										--decimal number correctness check
							IF decimal_str<>'6' THEN									--decimal number correctness check
								IF decimal_str<>'7' THEN								--decimal number correctness check
									IF decimal_str<>'8' THEN							--decimal number correctness check
										IF decimal_str<>'9' THEN						--decimal number correctness check
											WRITE(CR,'Only positive integer numbers',	
											CR,'from 0 to 9 are permitted',CR)			--ERROR handling message
											GOTO decimal_input						--on error jump to label
										ENDIF
									ENDIF
								ENDIF
							ENDIF
						ENDIF
					ENDIF
				ENDIF
			ENDIF
		ENDIF
	ENDIF
	
	CNV_STR_INT(decimal_str,decimal_int)	--convert string into integer

	IF operation = '+' THEN						--overwriting symbol with number for SELECT command
		operation_num = 1
	ENDIF
	
	IF operation = '-' THEN						--overwriting symbol with number for SELECT command
		operation_num = 2
	ENDIF
	
	IF operation = 'x' THEN						--overwriting symbol with number for SELECT command
		operation_num = 3
	ENDIF
	
	IF operation = 'X' THEN						--overwriting symbol with number for SELECT command
		operation_num = 3
	ENDIF
	
	IF operation = '/' THEN						--overwriting symbol with number for SELECT command
		operation_num = 4
	ENDIF
	
	IF operation = '^' THEN						--overwriting symbol with number for SELECT command
		operation_num = 5
	ENDIF
	
	IF operation = 'sin' THEN					--overwriting symbol with number for SELECT command
		operation_num = 6
	ENDIF
	
	IF operation = 'SIN' THEN					--overwriting symbol with number for SELECT command
		operation_num = 6
	ENDIF
	
	IF operation = 'cos' THEN					--overwriting symbol with number for SELECT command
		operation_num = 7
	ENDIF
	
	IF operation = 'COS' THEN					--overwriting symbol with number for SELECT command
		operation_num = 7
	ENDIF
	
	IF operation = 'tg' THEN					--overwriting symbol with number for SELECT command
		operation_num = 8
	ENDIF
	
	IF operation = 'TG' THEN					--overwriting symbol with number for SELECT command
		operation_num = 8						
	ENDIF
	
	IF operation = 'ctg' THEN					--overwriting symbol with number for SELECT command
		operation_num = 9
	ENDIF
	
	IF operation = 'CTG' THEN					--overwriting symbol with number for SELECT command
		operation_num= 9
	ENDIF
	
	SELECT operation_num OF											--select opearation to execute
		CASE(1):														--if sum was selected
			result=num1+num2											--calculation
			WRITE(CR,num1::0::decimal_int,' +',num2::1::decimal_int,
			' =',result::0::decimal_int,CR)								--write whole expression and result with predifinied decimal number 
			CNV_REAL_STR(num1,decimal_int,decimal_int,num1_str)	--convert real into string
			CNV_REAL_STR(num2,decimal_int,decimal_int,num2_str)	--convert real into string
			CNV_REAL_STR(result,decimal_int,decimal_int,result_str)	--convert real into string
			result_log=num1_str+' +'+num2_str+' ='+result_str			--save expression in single string variable
		CASE(2):														--select operation to execute
			result=num1-num2											--if difference was selected
			WRITE(CR,num1::0::decimal_int,' -',num2::1::decimal_int,
			' =',result::0::decimal_int,CR)								--write whole expression and result with predifinied decimal number 
			CNV_REAL_STR(num1,decimal_int,decimal_int,num1_str)	--convert real into string
			CNV_REAL_STR(num2,decimal_int,decimal_int,num2_str)	--convert real into string
			CNV_REAL_STR(result,decimal_int,decimal_int,result_str)	--convert real into string
			result_log=num1_str+' -'+num2_str+' ='+result_str			--save expression in single string variable
		CASE(3):														--select operation to execute
			result=num1*num2											--if multiplication was selected										
			WRITE(CR,num1::0::decimal_int,' x',num2::1::decimal_int,
			' =',result::0::decimal_int,CR)								--write whole expression and result with predifinied decimal number
			CNV_REAL_STR(num1,decimal_int,decimal_int,num1_str)	--convert real into string
			CNV_REAL_STR(num2,decimal_int,decimal_int,num2_str)	--convert real into string
			CNV_REAL_STR(result,decimal_int,decimal_int,result_str)	--convert real into string
			result_log=num1_str+' *'+num2_str+' ='+result_str			--save expression in single string variable
		CASE(4):														--select operation to execute
			result=num1/num2											--if divide operation was selected 
			WRITE(CR,num1::0::decimal_int,' /',num2::1::decimal_int,
			' =',result::0::decimal_int,CR)								--write whole expression and result with predifinied decimal number 
			CNV_REAL_STR(num1,decimal_int,decimal_int,num1_str)	--convert real into string
			CNV_REAL_STR(num2,decimal_int,decimal_int,num2_str)	--convert real into string
			CNV_REAL_STR(result,decimal_int,decimal_int,result_str)	--convert real into string
			result_log=num1_str+' /'+num2_str+' ='+result_str			--save expression in single string variable
		CASE(5):														--select operation to execute
			result=num1												--preparing for power multiplication
			IF exponent=0 THEN										--special case: exponent=0
				result=1
			WRITE(CR,num1::0::decimal_int,' ^', 
			exponent::1::decimal_int,' =',result::0::decimal_int,CR)			--write whole expression and result with predifinied decimal number	
			CNV_REAL_STR(num1,decimal_int,decimal_int,num1_str)		--convert real into string
			CNV_INT_STR(exponent,decimal_int,decimal_int,exponent_str)	--convert integer into string
			CNV_REAL_STR(result,decimal_int,decimal_int,result_str)		--convert real into string
			result_log=num1_str+' ^'+exponent_str+' ='+result_str			--save expression in single string variable									
			ENDIF
			IF exponent<0 THEN											--special case: exponent < 0
				num1_inverse=1/num1										--base inverse
				exponent=exponent*(-1)										--change negative exponent to positive
				result=num1_inverse										--preparing for power multiplication
			FOR i=2 TO exponent DO										--FOR loop to execute power multiplication 
				result=result*num1_inverse									--calculation
			ENDFOR
			WRITE(CR,num1::0::decimal_int,' ^',' -', 
			exponent::0::decimal_int,' =',result::0::decimal_int,CR)			--write whole expression and result with predifinied decimal number
			CNV_REAL_STR(num1,decimal_int,decimal_int,num1_str)		--convert real into string
			CNV_INT_STR(exponent,decimal_int,decimal_int,exponent_str)	--convert integer into string
			CNV_REAL_STR(result,decimal_int,decimal_int,result_str)		--convert real into string
			result_log=num1_str+' ^'+exponent_str+' ='+result_str			--save expression in single string variable
			ELSE															--alternative: if exponent > 0			
			FOR i=2 TO exponent DO										--FOR loop to execute power multiplication 
				result=result*num1											--calculation
			ENDFOR
			WRITE(CR,num1::0::decimal_int,' ^', 
			exponent::1::decimal_int,' =',result::0::decimal_int,CR)			--write whole expression and result with predifinied decimal number 
			CNV_REAL_STR(num1,decimal_int,decimal_int,num1_str)		--convert real into string
			CNV_INT_STR(exponent,decimal_int,decimal_int,exponent_str)	--convert integer into string
			CNV_REAL_STR(result,decimal_int,decimal_int,result_str)		--convert real into string
			result_log=num1_str+' ^'+exponent_str+' ='+result_str			--save expression in single string variable
			ENDIF
		CASE(6):														--select operation to execute
			result=SIN(num1)											--calculation											
			WRITE(CR,'sin',num1::0::decimal_int,' =',					
			result::0::decimal_int,CR)									--write whole expression and result with predifinied decimal number
			CNV_REAL_STR(num1,decimal_int,decimal_int,num1_str)	--convert real into string 
			CNV_REAL_STR(result,decimal_int,decimal_int,result_str)	--convert real into string	
			result_log='sin'+num1_str+' ='+result_str					--save expression in single string variable								
		CASE(7):														--select operation to execute
			result=COS(num1)											--calculation							
			WRITE(CR,'cos',num1::0::decimal_int,' =',
			result::0::decimal_int,CR)									--write whole expression and result with predifinied decimal number 
			CNV_REAL_STR(num1,decimal_int,decimal_int,num1_str)	--convert real into string 
			CNV_REAL_STR(result,decimal_int,decimal_int,result_str)	--convert real into string	
			result_log='cos'+num1_str+' ='+result_str					--save expression in single string variable			
		CASE(8):														--select operation to execute
			result=TAN(num1)											--calculation
			WRITE(CR,'tg',num1::0::decimal_int,' =',
			result::0::decimal_int,CR)									--write whole expression and result with predifinied decimal number
			CNV_REAL_STR(num1,decimal_int,decimal_int,num1_str)	--convert real into string 
			CNV_REAL_STR(result,decimal_int,decimal_int,result_str)	--convert real into string	
			result_log='tg'+num1_str+' ='+result_str						--save expression in single string variable 
		CASE(9):														--select operation to execute
			result=COS(num1)/SIN(num1)								--calculation
			WRITE(CR,'ctg',num1::0::decimal_int,' =',
			result::0::decimal_int,CR)									--write whole expression and result with predifinied decimal number
			CNV_REAL_STR(num1,decimal_int,decimal_int,num1_str)	--convert real into string 
			CNV_REAL_STR(result,decimal_int,decimal_int,result_str)	--convert real into string	
			result_log='ctg'+num1_str+' ='+result_str					--save expression in single string variable 		
	ENDSELECT

	question::															--question label
	WRITE(CR,'Perform new calculation? [Y/N] ')						--input data request
	READ(ans)															--read answer
	IF ans<>'y' THEN													--both: miniscule and capital 'Y' are permitted
		IF ans<>'Y' THEN												--both: miniscule and capital 'Y' are permitted
			IF ans<>'n' THEN											--both: miniscule and capital 'N' are permitted
				IF ans<>'N' THEN										--both: miniscule and capital 'N' are permitted
					GOTO question										--neither 'Y/y' nor 'N/n' were selected jump to question label
				ELSE
					question1::															--question label
					WRITE(CR,'Save calculation? [Y/N] ')								--input data request
					READ(ans2)														--read answer
					IF ans2<>'y' THEN													--both: miniscule and capital 'Y' are permitted
						IF ans2<>'Y' THEN												--both: miniscule and capital 'Y' are permitted
							IF ans2<>'n' THEN											--both: miniscule and capital 'N' are permitted
								IF ans2<>'N' THEN										--both: miniscule and capital 'N' are permitted
									GOTO question1									--neither 'Y/y' nor 'N/n' were selected jump to question label
								ELSE
									WRITE(CHR(128), CHR (137))						--clear USER screen
									FORCE_SPMENU(TP_PANEL , SPI_TPSELECT,1)	--display program select menu
									ABORT												--abort program
								ENDIF
							ELSE
								WRITE(CHR(128), CHR (137))							--clear USER screen
								FORCE_SPMENU(TP_PANEL , SPI_TPSELECT,1)		--display program select menu
								ABORT													--abort program
							ENDIF
						ELSE
							GET_TIME(time_struct)
							second=time_struct 		MOD 	32--extraction of 5 bits representing seconds in a whole bit string
							time_struct =time_struct  	DIV 	32--restore original bit string
							minute=time_struct 			MOD	64--extraction of 6 bits representing minutes in a whole bit string
							time_struct =time_struct 	DIV		64--restore original bit string
							hour=time_struct 			MOD	32--extraction of 5 bits representing hours in a whole bit string
							time_struct =time_struct 	DIV		32--restore original bit string
							day=time_struct 			MOD	32--extraction of 5 bits representing days in a whole bit string
							time_struct =time_struct 	DIV		32--restore original bit string
							month=time_struct 			MOD	16--extraction of 4 bits representing months in a whole bit string
							time_struct =time_struct 	DIV		16--restore original bit string
							year=time_struct 			MOD	128--extraction of 7 bits representing years in a whole bit string
					
							second=second*2	--seconds resolution is 2 sec
							year=year+1980	--year is counted from 1980
					
							----------Second
							CNV_INT_STR(second,2,0,second_str) 	--format specified INTEGER into a STRING
							second_str=SUB_STR(second_str,2,2) 	--get only 2 last signs
							IF (second<10) THEN					--add '0' if number is one digit
								second_str='0'+second_str
							ENDIF
	
							----------Minute
							CNV_INT_STR(minute,2,0,minute_str)	--format specified INTEGER into a STRING
							minute_str=SUB_STR(minute_str,2,2)	--get only 2 last signs
							IF (minute<10) THEN					--add '0' if number is one digit
								minute_str='0'+minute_str
							ENDIF

							----------Hour
							CNV_INT_STR(hour,2,0,hour_str)		--format specified INTEGER into a STRING
							hour_str=SUB_STR(hour_str,2,2)		--get only 2 last signs
							IF (hour<10) THEN						--add '0' if number is one digit
								hour_str='0'+hour_str
							ENDIF	

							----------Day
							CNV_INT_STR(day,2,0,day_str)			--format specified INTEGER into a STRING
							day_str=SUB_STR(day_str,2,2)			--get only 2 last signs
							IF (day<10) THEN						--add '0' if number is one digit
								day_str='0'+day_str
							ENDIF
	
							----------Month
							CNV_INT_STR(month,2,0,month_str)	--format specified INTEGER into a STRING
							month_str=SUB_STR(month_str,2,2)	--get only 2 last signs
							IF (month<10) THEN					--add '0' if number is one digit
								month_str='0'+month_str
							ENDIF
	
							----------Year
							CNV_INT_STR(year,2,0,year_str)		--format specified INTEGER into a STRING

							file_path='UD1:results_log.kl'							--define file path
							OPEN FILE file_save('AP',file_path)						--file open
							WRITE file_save(CR, '--------', year_str,'-',month_str,'-',
							day_str::4,hour_str,':',minute_str,':',second_str,' --------',
							CR,result_log,CR)										--write current data and hour
					
							CLOSE FILE file_save									--close file
							WRITE(CHR(128), CHR (137))							--clear USER screen
							FORCE_SPMENU(TP_PANEL , SPI_TPSELECT,1)		--display program select menu
							ABORT													--abort program
						ENDIF
					ELSE
						GET_TIME(time_struct)
						second=time_struct 		MOD 	32--extraction of 5 bits representing seconds in a whole bit string
						time_struct =time_struct  	DIV 	32--restore original bit string
						minute=time_struct 			MOD	64--extraction of 6 bits representing minutes in a whole bit string
						time_struct =time_struct 	DIV		64--restore original bit string
						hour=time_struct 			MOD	32--extraction of 5 bits representing hours in a whole bit string
						time_struct =time_struct 	DIV		32--restore original bit string
						day=time_struct 			MOD	32--extraction of 5 bits representing days in a whole bit string
						time_struct =time_struct 	DIV		32--restore original bit string
						month=time_struct 			MOD	16--extraction of 4 bits representing months in a whole bit string
						time_struct =time_struct 	DIV		16--restore original bit string
						year=time_struct 			MOD	128--extraction of 7 bits representing years in a whole bit string
					
						second=second*2	--seconds resolution is 2 sec
						year=year+1980	--year is counted from 1980
					
						----------Second
						CNV_INT_STR(second,2,0,second_str) 	--format specified INTEGER into a STRING
						second_str=SUB_STR(second_str,2,2) 	--get only 2 last signs
						IF (second<10) THEN					--add '0' if number is one digit
							second_str='0'+second_str
						ENDIF
	
						----------Minute
						CNV_INT_STR(minute,2,0,minute_str)	--format specified INTEGER into a STRING
						minute_str=SUB_STR(minute_str,2,2)	--get only 2 last signs
						IF (minute<10) THEN					--add '0' if number is one digit
							minute_str='0'+minute_str
						ENDIF

						----------Hour
						CNV_INT_STR(hour,2,0,hour_str)		--format specified INTEGER into a STRING
						hour_str=SUB_STR(hour_str,2,2)		--get only 2 last signs
						IF (hour<10) THEN						--add '0' if number is one digit
							hour_str='0'+hour_str
						ENDIF	

						----------Day
						CNV_INT_STR(day,2,0,day_str)			--format specified INTEGER into a STRING
						day_str=SUB_STR(day_str,2,2)			--get only 2 last signs
						IF (day<10) THEN						--add '0' if number is one digit
							day_str='0'+day_str
						ENDIF
	
						----------Month
						CNV_INT_STR(month,2,0,month_str)	--format specified INTEGER into a STRING
						month_str=SUB_STR(month_str,2,2)	--get only 2 last signs
						IF (month<10) THEN					--add '0' if number is one digit
							month_str='0'+month_str
						ENDIF
	
						----------Year
						CNV_INT_STR(year,2,0,year_str)		--format specified INTEGER into a STRING

						file_path='UD1:results_log.kl'							--define file path
						OPEN FILE file_save('AP',file_path)						--file open
						WRITE file_save(CR, '--------', year_str,'-',month_str,'-',
						day_str::4,hour_str,':',minute_str,':',second_str,' --------',
						CR,result_log,CR)										--write current data and hour	
											
						CLOSE FILE file_save									--close file
						WRITE(CHR(128), CHR (137))							--clear user screen
						FORCE_SPMENU(TP_PANEL , SPI_TPSELECT,1)		--display program select menu
						ABORT													--abort program
					ENDIF
				ENDIF
			ELSE
				question2::															--question label													
				WRITE(CR,'Save calculation? [Y/N] ')								--input data request
				READ(ans2)														--read answer
				IF ans2<>'y' THEN													--both: miniscule and capital 'Y' are permitted
					IF ans2<>'Y' THEN												--both: miniscule and capital 'Y' are permitted
						IF ans2<>'n' THEN											--both: miniscule and capital 'N' are permitted
							IF ans2<>'N' THEN										--both: miniscule and capital 'N' are permitted
								GOTO question2									--neither 'Y/y' nor 'N/n' were selected jump to question label
							ELSE
								WRITE(CHR(128), CHR (137))						--clear USER screen
								FORCE_SPMENU(TP_PANEL , SPI_TPSELECT,1)	--display program select menu
								ABORT												--abort program
							ENDIF
						ELSE
							WRITE(CHR(128), CHR (137))							--clear USER screen
							FORCE_SPMENU(TP_PANEL , SPI_TPSELECT,1)		--display program select menu
							ABORT													--abort program
						ENDIF
					ELSE
						GET_TIME(time_struct)
						second=time_struct 		MOD 	32--extraction of 5 bits representing seconds in a whole bit string
						time_struct =time_struct  	DIV 	32--restore original bit string
						minute=time_struct 			MOD	64--extraction of 6 bits representing minutes in a whole bit string
						time_struct =time_struct 	DIV		64--restore original bit string
						hour=time_struct 			MOD	32--extraction of 5 bits representing hours in a whole bit string
						time_struct =time_struct 	DIV		32--restore original bit string
						day=time_struct 			MOD	32--extraction of 5 bits representing days in a whole bit string
						time_struct =time_struct 	DIV		32--restore original bit string
						month=time_struct 			MOD	16--extraction of 4 bits representing months in a whole bit string
						time_struct =time_struct 	DIV		16--restore original bit string
						year=time_struct 			MOD	128--extraction of 7 bits representing years in a whole bit string
					
						second=second*2	--seconds resolution is 2 sec
						year=year+1980	--year is counted from 1980
					
						----------Second
						CNV_INT_STR(second,2,0,second_str) 	--format specified INTEGER into a STRING
						second_str=SUB_STR(second_str,2,2) 	--get only 2 last signs
						IF (second<10) THEN					--add '0' if number is one digit
							second_str='0'+second_str
						ENDIF
	
						----------Minute
						CNV_INT_STR(minute,2,0,minute_str)	--format specified INTEGER into a STRING
						minute_str=SUB_STR(minute_str,2,2)	--get only 2 last signs
						IF (minute<10) THEN					--add '0' if number is one digit
							minute_str='0'+minute_str
						ENDIF

						----------Hour
						CNV_INT_STR(hour,2,0,hour_str)		--format specified INTEGER into a STRING
						hour_str=SUB_STR(hour_str,2,2)		--get only 2 last signs
						IF (hour<10) THEN						--add '0' if number is one digit
							hour_str='0'+hour_str
						ENDIF	

						----------Day
						CNV_INT_STR(day,2,0,day_str)			--format specified INTEGER into a STRING
						day_str=SUB_STR(day_str,2,2)			--get only 2 last signs
						IF (day<10) THEN						--add '0' if number is one digit
							day_str='0'+day_str
						ENDIF
	
						----------Month
						CNV_INT_STR(month,2,0,month_str)	--format specified INTEGER into a STRING
						month_str=SUB_STR(month_str,2,2)	--get only 2 last signs
						IF (month<10) THEN					--add '0' if number is one digit
							month_str='0'+month_str
						ENDIF
	
						----------Year
						CNV_INT_STR(year,2,0,year_str)		--format specified INTEGER into a STRING

						file_path='UD1:results_log.kl'							--define file path
						OPEN FILE file_save('AP',file_path)						--file open
						WRITE file_save(CR, '--------', year_str,'-',month_str,'-',
						day_str::4,hour_str,':',minute_str,':',second_str,' --------',
						CR,result_log,CR)										--write current data and hour
						
						CLOSE FILE file_save		--close file
							WRITE(CHR(128), CHR (137))						--clear USER screen
							FORCE_SPMENU(TP_PANEL , SPI_TPSELECT,1)	--display program select menu
							ABORT												--abort program
					ENDIF
				ELSE
					GET_TIME(time_struct)
					second=time_struct 		MOD 	32--extraction of 5 bits representing seconds in a whole bit string
					time_struct =time_struct  	DIV 	32--restore original bit string
					minute=time_struct 			MOD	64--extraction of 6 bits representing minutes in a whole bit string
					time_struct =time_struct 	DIV		64--restore original bit string
					hour=time_struct 			MOD	32--extraction of 5 bits representing hours in a whole bit string
					time_struct =time_struct 	DIV		32--restore original bit string
					day=time_struct 			MOD	32--extraction of 5 bits representing days in a whole bit string
					time_struct =time_struct 	DIV		32--restore original bit string
					month=time_struct 			MOD	16--extraction of 4 bits representing months in a whole bit string
					time_struct =time_struct 	DIV		16--restore original bit string
					year=time_struct 			MOD	128--extraction of 7 bits representing years in a whole bit string
					
					second=second*2	--seconds resolution is 2 sec
					year=year+1980	--year is counted from 1980
					
					----------Second
					CNV_INT_STR(second,2,0,second_str) 	--format specified INTEGER into a STRING
					second_str=SUB_STR(second_str,2,2) 	--get only 2 last signs
					IF (second<10) THEN					--add '0' if number is one digit
						second_str='0'+second_str
					ENDIF
	
					----------Minute
					CNV_INT_STR(minute,2,0,minute_str)	--format specified INTEGER into a STRING
					minute_str=SUB_STR(minute_str,2,2)	--get only 2 last signs
					IF (minute<10) THEN					--add '0' if number is one digit
						minute_str='0'+minute_str
					ENDIF

					----------Hour
					CNV_INT_STR(hour,2,0,hour_str)		--format specified INTEGER into a STRING
					hour_str=SUB_STR(hour_str,2,2)		--get only 2 last signs
					IF (hour<10) THEN						--add '0' if number is one digit
						hour_str='0'+hour_str
					ENDIF	

					----------Day
					CNV_INT_STR(day,2,0,day_str)			--format specified INTEGER into a STRING
					day_str=SUB_STR(day_str,2,2)			--get only 2 last signs
					IF (day<10) THEN						--add '0' if number is one digit
						day_str='0'+day_str
					ENDIF
	
					----------Month
					CNV_INT_STR(month,2,0,month_str)	--format specified INTEGER into a STRING
					month_str=SUB_STR(month_str,2,2)	--get only 2 last signs
					IF (month<10) THEN					--add '0' if number is one digit
						month_str='0'+month_str
					ENDIF
	
					----------Year
					CNV_INT_STR(year,2,0,year_str)		--format specified INTEGER into a STRING

					file_path='UD1:results_log.kl'							--define file path
					OPEN FILE file_save('AP',file_path)						--file open
					WRITE file_save(CR, '--------', year_str,'-',month_str,'-',
					day_str::4,hour_str,':',minute_str,':',second_str,' --------',
					CR,result_log,CR)										--write current data and hour
					
					CLOSE FILE file_save									--close file
					WRITE(CHR(128), CHR (137))							--clear USER screen
					FORCE_SPMENU(TP_PANEL , SPI_TPSELECT,1)		--display program select menu
					ABORT													--abort program
				ENDIF
			ENDIF
		ELSE
			question3::										--question label
			WRITE(CR,'Save calculation? [Y/N] ')			--input data request
			READ(ans2)									--read answer
			IF ans2<>'y' THEN								--both: miniscule and capital 'Y' are permitted
				IF ans2<>'Y' THEN							--both: miniscule and capital 'Y' are permitted
					IF ans2<>'n' THEN						--both: miniscule and capital 'N' are permitted
						IF ans2<>'N' THEN					--both: miniscule and capital 'N' are permitted
							GOTO question3				--neither 'Y/y' nor 'N/n' were selected jump to question label
						ELSE
							WRITE(CHR(128), CHR (137))	--clear USER screen
							GOTO start						--jump TO start label
						ENDIF
					ELSE
						WRITE(CHR(128), CHR (137))		--clear USER screen
						GOTO start							--jump TO start label
					ENDIF
				ELSE
					GET_TIME(time_struct)
					second=time_struct 		MOD 	32--extraction of 5 bits representing seconds in a whole bit string
					time_struct =time_struct  	DIV 	32--restore original bit string
					minute=time_struct 			MOD	64--extraction of 6 bits representing minutes in a whole bit string
					time_struct =time_struct 	DIV		64--restore original bit string
					hour=time_struct 			MOD	32--extraction of 5 bits representing hours in a whole bit string
					time_struct =time_struct 	DIV		32--restore original bit string
					day=time_struct 			MOD	32--extraction of 5 bits representing days in a whole bit string
					time_struct =time_struct 	DIV		32--restore original bit string
					month=time_struct 			MOD	16--extraction of 4 bits representing months in a whole bit string
					time_struct =time_struct 	DIV		16--restore original bit string
					year=time_struct 			MOD	128--extraction of 7 bits representing years in a whole bit string
					
					second=second*2	--seconds resolution is 2 sec
					year=year+1980	--year is counted from 1980
					
					----------Second
					CNV_INT_STR(second,2,0,second_str) 	--format specified INTEGER into a STRING
					second_str=SUB_STR(second_str,2,2) 	--get only 2 last signs
					IF (second<10) THEN					--add '0' if number is one digit
						second_str='0'+second_str
					ENDIF
	
					----------Minute
					CNV_INT_STR(minute,2,0,minute_str)	--format specified INTEGER into a STRING
					minute_str=SUB_STR(minute_str,2,2)	--get only 2 last signs
					IF (minute<10) THEN					--add '0' if number is one digit
						minute_str='0'+minute_str
					ENDIF

					----------Hour
					CNV_INT_STR(hour,2,0,hour_str)		--format specified INTEGER into a STRING
					hour_str=SUB_STR(hour_str,2,2)		--get only 2 last signs
					IF (hour<10) THEN						--add '0' if number is one digit
						hour_str='0'+hour_str
					ENDIF	

					----------Day
					CNV_INT_STR(day,2,0,day_str)			--format specified INTEGER into a STRING
					day_str=SUB_STR(day_str,2,2)			--get only 2 last signs
					IF (day<10) THEN						--add '0' if number is one digit
						day_str='0'+day_str
					ENDIF
	
					----------Month
					CNV_INT_STR(month,2,0,month_str)	--format specified INTEGER into a STRING
					month_str=SUB_STR(month_str,2,2)	--get only 2 last signs
					IF (month<10) THEN					--add '0' if number is one digit
						month_str='0'+month_str
					ENDIF
	
					----------Year
					CNV_INT_STR(year,2,0,year_str)		--format specified INTEGER into a STRING

					file_path='UD1:results_log.kl'												--define file path
					OPEN FILE file_save('AP',file_path)											--file open
					WRITE file_save(CR, '--------', year_str,'-',month_str,'-',
					day_str::4,hour_str,':',minute_str,':',second_str,' --------',CR,result_log,CR)	--write current data, hour and expression						
					CLOSE FILE file_save														--close file
					WRITE(CHR(128), CHR (137))												--clear USER screen
					GOTO start																	--jump TO start label
				ENDIF
			ELSE
				GET_TIME(time_struct)
					second=time_struct 		MOD 	32--extraction of 5 bits representing seconds in a whole bit string
					time_struct =time_struct  	DIV 	32--restore original bit string
					minute=time_struct 			MOD	64--extraction of 6 bits representing minutes in a whole bit string
					time_struct =time_struct 	DIV		64--restore original bit string
					hour=time_struct 			MOD	32--extraction of 5 bits representing hours in a whole bit string
					time_struct =time_struct 	DIV		32--restore original bit string
					day=time_struct 			MOD	32--extraction of 5 bits representing days in a whole bit string
					time_struct =time_struct 	DIV		32--restore original bit string
					month=time_struct 			MOD	16--extraction of 4 bits representing months in a whole bit string
					time_struct =time_struct 	DIV		16--restore original bit string
					year=time_struct 			MOD	128--extraction of 7 bits representing years in a whole bit string
					
					second=second*2	--seconds resolution is 2 sec
					year=year+1980	--year is counted from 1980
					
					----------Second
					CNV_INT_STR(second,2,0,second_str) 	--format specified INTEGER into a STRING
					second_str=SUB_STR(second_str,2,2) 	--get only 2 last signs
					IF (second<10) THEN					--add '0' if number is one digit
						second_str='0'+second_str
					ENDIF
	
					----------Minute
					CNV_INT_STR(minute,2,0,minute_str)	--format specified INTEGER into a STRING
					minute_str=SUB_STR(minute_str,2,2)	--get only 2 last signs
					IF (minute<10) THEN					--add '0' if number is one digit
						minute_str='0'+minute_str
					ENDIF

					----------Hour
					CNV_INT_STR(hour,2,0,hour_str)		--format specified INTEGER into a STRING
					hour_str=SUB_STR(hour_str,2,2)		--get only 2 last signs
					IF (hour<10) THEN						--add '0' if number is one digit
						hour_str='0'+hour_str
					ENDIF	

					----------Day
					CNV_INT_STR(day,2,0,day_str)			--format specified INTEGER into a STRING
					day_str=SUB_STR(day_str,2,2)			--get only 2 last signs
					IF (day<10) THEN						--add '0' if number is one digit
						day_str='0'+day_str
					ENDIF
	
					----------Month
					CNV_INT_STR(month,2,0,month_str)	--format specified INTEGER into a STRING
					month_str=SUB_STR(month_str,2,2)	--get only 2 last signs
					IF (month<10) THEN					--add '0' if number is one digit
						month_str='0'+month_str
					ENDIF
	
					----------Year
					CNV_INT_STR(year,2,0,year_str)		--format specified INTEGER into a STRING

					file_path='UD1:results_log.kl'							--define file path
					OPEN FILE file_save('AP',file_path)						--file open
					WRITE file_save(CR, '--------', year_str,'-',month_str,'-',
					day_str::4,hour_str,':',minute_str,':',second_str,' --------',
					CR,result_log,CR)										--write current data, hour and expressio
					CLOSE FILE file_save									--close file
				WRITE(CHR(128), CHR (137))								--clear USER screen
				GOTO start													--jump TO start label
			ENDIF
		ENDIF
	ELSE
	question4::											--question label
		WRITE(CR,'Save calculation? [Y/N] ')			--data input request
		READ(ans2)									--read answer
		IF ans2<>'y' THEN								--both: miniscule and capital 'Y' are permitted
			IF ans2<>'Y' THEN							--both: miniscule and capital 'Y' are permitted
				IF ans2<>'n' THEN						--both: miniscule and capital 'Y' are permitted
					IF ans2<>'N' THEN					--both: miniscule and capital 'Y' are permitted
						GOTO question4				--neither 'Y/y' nor 'N/n' were selected jump to question label
					ELSE
						WRITE(CHR(128), CHR (137))	--clear USER screen
						GOTO start						--jump TO start label
					ENDIF
				ELSE
					WRITE(CHR(128), CHR (137))		--clear USER screen
					GOTO start							--jump TO start label
				ENDIF
			ELSE
				GET_TIME(time_struct)
					second=time_struct 		MOD 	32--extraction of 5 bits representing seconds in a whole bit string
					time_struct =time_struct  	DIV 	32--restore original bit string
					minute=time_struct 			MOD	64--extraction of 6 bits representing minutes in a whole bit string
					time_struct =time_struct 	DIV		64--restore original bit string
					hour=time_struct 			MOD	32--extraction of 5 bits representing hours in a whole bit string
					time_struct =time_struct 	DIV		32--restore original bit string
					day=time_struct 			MOD	32--extraction of 5 bits representing days in a whole bit string
					time_struct =time_struct 	DIV		32--restore original bit string
					month=time_struct 			MOD	16--extraction of 4 bits representing months in a whole bit string
					time_struct =time_struct 	DIV		16--restore original bit string
					year=time_struct 			MOD	128--extraction of 7 bits representing years in a whole bit string
					
					second=second*2	--seconds resolution is 2 sec
					year=year+1980	--year is counted from 1980
					
					----------Second
					CNV_INT_STR(second,2,0,second_str) 	--format specified INTEGER into a STRING
					second_str=SUB_STR(second_str,2,2) 	--get only 2 last signs
					IF (second<10) THEN					--add '0' if number is one digit
						second_str='0'+second_str
					ENDIF
	
					----------Minute
					CNV_INT_STR(minute,2,0,minute_str)	--format specified INTEGER into a STRING
					minute_str=SUB_STR(minute_str,2,2)	--get only 2 last signs
					IF (minute<10) THEN					--add '0' if number is one digit
						minute_str='0'+minute_str
					ENDIF

					----------Hour
					CNV_INT_STR(hour,2,0,hour_str)		--format specified INTEGER into a STRING
					hour_str=SUB_STR(hour_str,2,2)		--get only 2 last signs
					IF (hour<10) THEN						--add '0' if number is one digit
						hour_str='0'+hour_str
					ENDIF	

					----------Day
					CNV_INT_STR(day,2,0,day_str)			--format specified INTEGER into a STRING
					day_str=SUB_STR(day_str,2,2)			--get only 2 last signs
					IF (day<10) THEN						--add '0' if number is one digit
						day_str='0'+day_str
					ENDIF
	
					----------Month
					CNV_INT_STR(month,2,0,month_str)	--format specified INTEGER into a STRING
					month_str=SUB_STR(month_str,2,2)	--get only 2 last signs
					IF (month<10) THEN					--add '0' if number is one digit
						month_str='0'+month_str
					ENDIF
	
					----------Year
					CNV_INT_STR(year,2,0,year_str)		--format specified INTEGER into a STRING

					file_path='UD1:results_log.kl'							--define file path
					OPEN FILE file_save('AP',file_path)						--file open
					WRITE file_save(CR, '--------', year_str,'-',month_str,'-',
					day_str::4,hour_str,':',minute_str,':',second_str,' --------',
					CR,result_log,CR)										--write current data, hour and expression
					CLOSE FILE file_save									--close file
				WRITE(CHR(128), CHR (137))								--clear USER screen
				GOTO start													--jump to start label
			ENDIF
		ELSE
			GET_TIME(time_struct)
					second=time_struct 		MOD 	32--extraction of 5 bits representing seconds in a whole bit string
					time_struct =time_struct  	DIV 	32--restore original bit string
					minute=time_struct 			MOD	64--extraction of 6 bits representing minutes in a whole bit string
					time_struct =time_struct 	DIV		64--restore original bit string
					hour=time_struct 			MOD	32--extraction of 5 bits representing hours in a whole bit string
					time_struct =time_struct 	DIV		32--restore original bit string
					day=time_struct 			MOD	32--extraction of 5 bits representing days in a whole bit string
					time_struct =time_struct 	DIV		32--restore original bit string
					month=time_struct 			MOD	16--extraction of 4 bits representing months in a whole bit string
					time_struct =time_struct 	DIV		16--restore original bit string
					year=time_struct 			MOD	128--extraction of 7 bits representing years in a whole bit string
					
					second=second*2	--seconds resolution is 2 sec
					year=year+1980	--year is counted from 1980
					
					----------Second
					CNV_INT_STR(second,2,0,second_str) 	--format specified INTEGER into a STRING
					second_str=SUB_STR(second_str,2,2) 	--get only 2 last signs
					IF (second<10) THEN					--add '0' if number is one digit
						second_str='0'+second_str
					ENDIF
	
					----------Minute
					CNV_INT_STR(minute,2,0,minute_str)	--format specified INTEGER into a STRING
					minute_str=SUB_STR(minute_str,2,2)	--get only 2 last signs
					IF (minute<10) THEN					--add '0' if number is one digit
						minute_str='0'+minute_str
					ENDIF

					----------Hour
					CNV_INT_STR(hour,2,0,hour_str)		--format specified INTEGER into a STRING
					hour_str=SUB_STR(hour_str,2,2)		--get only 2 last signs
					IF (hour<10) THEN						--add '0' if number is one digit
						hour_str='0'+hour_str
					ENDIF	

					----------Day
					CNV_INT_STR(day,2,0,day_str)			--format specified INTEGER into a STRING
					day_str=SUB_STR(day_str,2,2)			--get only 2 last signs
					IF (day<10) THEN						--add '0' if number is one digit
						day_str='0'+day_str
					ENDIF
	
					----------Month
					CNV_INT_STR(month,2,0,month_str)	--format specified INTEGER into a STRING
					month_str=SUB_STR(month_str,2,2)	--get only 2 last signs
					IF (month<10) THEN					--add '0' if number is one digit
						month_str='0'+month_str
					ENDIF
	
					----------Year
					CNV_INT_STR(year,2,0,year_str)		--format specified INTEGER into a STRING

					file_path='UD1:results_log.kl'												--define file path
					OPEN FILE file_save('AP',file_path)											--file open
					WRITE file_save(CR, '--------', year_str,'-',month_str,'-',
					day_str::4,hour_str,':',minute_str,':',second_str,' --------',CR,result_log,CR)	--write current data, hour and expression
					CLOSE FILE file_save														--close file
			WRITE(CHR(128), CHR (137))														--clear USER screen
			GOTO start																			--jump TO start label
		ENDIF
	ENDIF
END Calculator




